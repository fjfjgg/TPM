/*
    This file is part of Tool Provider Manager - Manager of LTI Tool Providers
    for learning platforms.
    Copyright (C) 2022  Francisco José Fernández Jiménez.

    Tool Provider Manager is free software: you can redistribute it and/or
    modify it under the terms of the GNU General Public License as published
    by the Free Software Foundation, either version 3 of the License, or (at
    your option) any later version.

    Tool Provider Manager is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
    Public License for more details.

    You should have received a copy of the GNU General Public License along
    with Tool Provider Manager. If not, see <https://www.gnu.org/licenses/>.
*/

package es.us.dit.lti.runner;

import java.io.Reader;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;

/**
 * Configuration of the {@link ToolRunnerType#TR_HTTP} type tool.
 *
 * @author Francisco José Fernández Jiménez
 */
public class HttpToolConfig {

	/**
	 * Parameters or headers of request.
	 *
	 * @author Francisco José Fernández Jiménez
	 */
	public static class Entry {
		/**
		 * Name of parameter or header.
		 */
		public String key;
		/**
		 * Value of parameter or header.
		 */
		public String value;
		/**
		 * Indicates whether the value or key supports substitutions.
		 */
		public boolean literal = true;
	}

	/* REQUEST */

	/**
	 * Request URL.
	 *
	 * <p>Supports argument expansion:
	 * <ul>
	 * <li><code>${n}</code> where n is a number it is replaced by the argument n
	 * <li><code>${%n}</code> same as before but the value is URLencoded
	 * </ul>
	 */
	private String url;
	/**
	 * Request method.
	 */
	private String requestMethod;
	/**
	 * Headers to send in the request.
	 *
	 * <p>Supports argument expansion:
	 * <ul>
	 * <li><code>${n}</code> where n is a number it is replaced by the argument n
	 * <li><code>${%n}</code> same as before but the value is URLencoded
	 * </ul>
	 */
	private List<Entry> headers;
	/**
	 * Content type.
	 *
	 * <p>Currently supported:
	 * <ul>
	 * <li><code>multipart/form-data</code> (to send file)
	 * <li><code>application/x-www-form-urlencoded</code> (form data)
	 * <li><code>(empty)</code> It has been manually set as header.
	 * </ul>
	 */
	private String contentType;

	/**
	 * Parameters of the request in case of using a contentType that supports it. If
	 * the parameter refers to the file delivered by the user, it is mandatory to
	 * use form-data mode.
	 *
	 * <p>Supports argument expansion:
	 * <ul>
	 * <li><code>${n}</code> where n is a number it is replaced by the argument n
	 * <li><code>${%n}</code> same as before but the value is URLencoded
	 * </ul>
	 */
	private List<Entry> parameters;

	/**
	 * Parameter name used for user supplied file.
	 *
	 * <p>If it is not null it is forced to use form-data mode.
	 */
	private String fileParameter;

	/**
	 * Body to be sent in the request if it supports it and the contentType is not
	 * explicitly specified.
	 *
	 * <p>Supports argument expansion:
	 * <ul>
	 * <li><code>${n}</code> where n is a number it is replaced by the argument n
	 * <li><code>${%n}</code> same as before but the value is URLencoded
	 * </ul>
	 */
	private String requestBody;

	/* RESPONSE */

	/**
	 * Treat the response as a JSON object to extract data from it. Attention: only
	 * data from the first level can be extracted, nesting is not supported. For
	 * more complex things, use JavaScript on the client.
	 */
	private boolean jsonResponse = false;

	/**
	 * Template of the response generated by the tool. If it is null, the received
	 * response is copied as is. Otherwise each element is considered a line to send
	 * as a response (it is ended with \n).
	 *
	 * <p>The following substitutions are allowed:
	 * <ul>
	 * <li><code>${body}</code> full body received in the request.
	 * <li><code>${h.header}</code> header value.
	 * <li><code>${j.property}</code> property of the JSON object (only if
	 * jsonResponse is true).
	 * <li><code>${%...}</code> the above by previously decoding (URLencoded).
	 * </ul>
	 */
	private List<String> responseTemplate;

	/**
	 * Score to return.
	 *
	 * <p>The same substitutions are used as in <code>responseTemplate</code>.
	 *
	 * <p>Must be an integer or string that can be converted to an integer. If it is
	 * null, the default values are returned.
	 */
	private String scoreTemplate;

	/**
	 * Default value of the score if the answer is of type 2XX.
	 */
	private int defaultScoreOnSuccess = 100;

	/**
	 * Does not verify certificates if TLS connections are used.
	 */
	private boolean noVerifyCertificate = false;

	/**
	 * Default value of the note if the answer is NOT of type 2XX.
	 */
	private int defaultScoreOnError = ToolRunner.ERROR_CORRECTOR_EXCEPTION;

	/**
	 * Deserialize from JSON string.
	 *
	 * @param json JSON string
	 * @return new object
	 */
	public static HttpToolConfig fromString(String json) {
		HttpToolConfig t = null;
		try {
			t = new Gson().fromJson(json, HttpToolConfig.class);
		} catch (final JsonSyntaxException e) {
			// ignore, t is null
			t = null;
		}
		return t;
	}

	/**
	 * Deserialize from JSON Reader.
	 *
	 * @param jsonReader JSON Reader
	 * @return new object
	 */
	public static HttpToolConfig fromString(Reader jsonReader) {
		HttpToolConfig t = null;
		try {
			t = new Gson().fromJson(jsonReader, HttpToolConfig.class);
		} catch (JsonSyntaxException | JsonIOException e) {
			// ignore, t is null
			t = null;
		}
		return t;
	}

	/**
	 * Convert this object to a JSON string.
	 *
	 * @return JSON string
	 */
	@Override
	public String toString() {
		final Gson gson = new GsonBuilder().setPrettyPrinting().serializeNulls().create();
		return gson.toJson(this);
	}

	/**
	 * Gets the request URL.
	 *
	 * @return the request URL
	 */
	public String getUrl() {
		return url;
	}

	/**
	 * Sets the request URL.
	 *
	 * <p>Supports argument expansion:
	 * <ul>
	 * <li><code>${n}</code> where n is a number it is replaced by the argument n
	 * <li><code>${%n}</code> same as before but the value is URLencoded
	 * </ul>
	 *
	 * @param url the URL to set
	 */
	public void setUrl(String url) {
		this.url = url;
	}

	/**
	 * Gets the request method.
	 *
	 * @return the request method
	 */
	public String getRequestMethod() {
		return requestMethod;
	}

	/**
	 * Sets the request method (GET, POST, ...).
	 *
	 * @param requestMethod the request method to set
	 */
	public void setRequestMethod(String requestMethod) {
		this.requestMethod = requestMethod;
	}

	/**
	 * Gets the headers to send in the request.
	 *
	 * @return the headers
	 */
	public List<Entry> getHeaders() {
		return headers;
	}

	/**
	 * Sets the headers to send in the request.
	 *
	 * <p>Supports argument expansion:
	 * <ul>
	 * <li><code>${n}</code> where n is a number it is replaced by the argument n
	 * <li><code>${%n}</code> same as before but the value is URLencoded
	 * </ul>
	 *
	 * @param headers the headers to set
	 */
	public void setHeaders(List<Entry> headers) {
		this.headers = headers;
	}

	/**
	 * Gets the content type of the request.
	 *
	 * @return the content type
	 */
	public String getContentType() {
		return contentType;
	}

	/**
	 * Sets the content type of the request.
	 *
	 * <p>Currently supported:
	 * <ul>
	 * <li><code>multipart/form-data</code> (to send file)
	 * <li><code>application/x-www-form-urlencoded</code> (form data)
	 * <li><code>(empty)</code> It has been manually set as header.
	 * </ul>
	 *
	 * @param contentType the content type to set
	 */
	public void setContentType(String contentType) {
		this.contentType = contentType;
	}

	/**
	 * Gets the parameters of the request in case of using a contentType that
	 * supports it.
	 *
	 * @return the parameters
	 */
	public List<Entry> getParameters() {
		return parameters;
	}

	/**
	 * Sets the parameters of the request in case of using a contentType that
	 * supports it. If the parameter refers to the file delivered by the user, it is
	 * mandatory to use form-data mode.
	 *
	 * <p>Supports argument expansion:
	 * <ul>
	 * <li><code>${n}</code> where n is a number it is replaced by the argument n
	 * <li><code>${%n}</code> same as before but the value is URLencoded
	 * </ul>
	 *
	 * @param parameters the parameters to set
	 */
	public void setParameters(List<Entry> parameters) {
		this.parameters = parameters;
	}

	/**
	 * Gets the file parameter name.
	 *
	 * @return the file parameter name
	 */
	public String getFileParameter() {
		return fileParameter;
	}

	/**
	 * Sets the parameter name used for user supplied file.
	 *
	 * <p>If it is not null it is forced to use form-data mode.
	 *
	 * @param fileParameter the file parameter name to set
	 */
	public void setFileParameter(String fileParameter) {
		this.fileParameter = fileParameter;
	}

	/**
	 * Gets the body to be sent in the request.
	 *
	 * @return the request body
	 */
	public String getRequestBody() {
		return requestBody;
	}

	/**
	 * Sets the body to be sent in the request if it supports it and the contentType
	 * is not explicitly specified.
	 *
	 * <p>Supports argument expansion:
	 * <ul>
	 * <li><code>${n}</code> where n is a number it is replaced by the argument n
	 * <li><code>${%n}</code> same as before but the value is URLencoded
	 * </ul>
	 *
	 * @param requestBody the request body to set
	 */
	public void setRequestBody(String requestBody) {
		this.requestBody = requestBody;
	}

	/**
	 * Gets if the response is treated as a JSON object to extract data from it.
	 *
	 * @return the jsonResponse true if it is enabled
	 */
	public boolean isJsonResponse() {
		return jsonResponse;
	}

	/**
	 * Enables treat the response as a JSON object to extract data from it.
	 *
	 * <p>Attention: only data from the first level can be extracted, nesting is not
	 * supported. For more complex things, use JavaScript on the client.
	 *
	 * @param jsonResponse the jsonResponse to set
	 */
	public void setJsonResponse(boolean jsonResponse) {
		this.jsonResponse = jsonResponse;
	}

	/**
	 * Gets the template of the response generated by the tool.
	 *
	 * @return the response template
	 */
	public List<String> getResponseTemplate() {
		return responseTemplate;
	}

	/**
	 * Sets the template of the response generated by the tool. If it is null, the
	 * received response is copied as is. Otherwise each element is considered a
	 * line to send as a response (it is ended with \n).
	 *
	 * <p>The following substitutions are allowed:
	 * <ul>
	 * <li><code>${body}</code> full body received in the request.
	 * <li><code>${h.header}</code> header value.
	 * <li><code>${j.property}</code> property of the JSON object (only if
	 * jsonResponse is true).
	 * <li><code>${%...}</code> the above by previously decoding (URLencoded).
	 * </ul>
	 *
	 * @param responseTemplate the response template to set
	 */
	public void setResponseTemplate(List<String> responseTemplate) {
		this.responseTemplate = responseTemplate;
	}

	/**
	 * Gets the score template.
	 *
	 * @return the score template
	 */
	public String getScoreTemplate() {
		return scoreTemplate;
	}

	/**
	 * Sets the score to return.
	 *
	 * <p>The same substitutions are used as in {@link #setResponseTemplate(List)}.
	 *
	 * <p>Must be an integer or string that can be converted to an integer. If it is
	 * null, the default values are returned.
	 *
	 * @param scoreTemplate the score template to set
	 */
	public void setScoreTemplate(String scoreTemplate) {
		this.scoreTemplate = scoreTemplate;
	}

	/**
	 * Gets the default value of the score if the answer is of type 2XX.
	 *
	 * @return the default score on success
	 */
	public int getDefaultScoreOnSuccess() {
		return defaultScoreOnSuccess;
	}

	/**
	 * Sets the default value of the score if the answer is of type 2XX.
	 *
	 * @param defaultScoreOnSuccess the default score on success to set
	 */
	public void setDefaultScoreOnSuccess(int defaultScoreOnSuccess) {
		this.defaultScoreOnSuccess = defaultScoreOnSuccess;
	}

	/**
	 * Gets if it does not verify certificates if TLS connections are used.
	 *
	 * @return the noVerifyCertificate
	 */
	public boolean isNoVerifyCertificate() {
		return noVerifyCertificate;
	}

	/**
	 * Sets if it does not verify certificates if TLS connections are used.
	 *
	 * @param noVerifyCertificate the noVerifyCertificate to set
	 */
	public void setNoVerifyCertificate(boolean noVerifyCertificate) {
		this.noVerifyCertificate = noVerifyCertificate;
	}

	/**
	 * Gets the default value of the note if the answer is NOT of type 2XX.
	 *
	 * @return the defaultScoreOnError
	 */
	public int getDefaultScoreOnError() {
		return defaultScoreOnError;
	}

	/**
	 * Sets the default value of the note if the answer is NOT of type 2XX.
	 *
	 * @param defaultScoreOnError the defaultScoreOnError to set
	 */
	public void setDefaultScoreOnError(int defaultScoreOnError) {
		this.defaultScoreOnError = defaultScoreOnError;
	}

}
